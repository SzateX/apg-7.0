/*  *************************************************************************************
    Copyright (c) 2021, Lowell D. Thomas
    All rights reserved.
    
    This file is part of APG Version 7.0.
    APG Version 7.0 may be used under the terms of the BSD 2-Clause License.
    
    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are met:
    
    1. Redistributions of source code must retain the above copyright notice, this
       list of conditions and the following disclaimer.
    
    2. Redistributions in binary form must reproduce the above copyright notice,
       this list of conditions and the following disclaimer in the documentation
       and/or other materials provided with the distribution.
    
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    
*   *************************************************************************************/
/** \file library/parserp.h
 * \brief Private header for the SABNF parser
 *
 * The declarations here are used internally by the parser.
 * Some of the APG utilities and helper objects will use this "inside" information
 * but the user should rarely need this header for an application. */

#ifndef LIB_PARSERP_H_
#define LIB_PARSERP_H_

/** \struct parser_init
 * \brief The initialization information generated by APG.
 *
 * This data is required to initialize the parser during construction.
 * It is generated by the API functions vApiOutput() and vpApiOutputParser().
 */
typedef struct  {
    uint32_t uiSizeofAchar; ///< \brief Minimum size, in bytes, required for the alphabet characters, \ref achar.
    uint32_t uiSizeofUint; ///< \brief  Minimum size, in bytes, required for the basic parser unsigned integer, \ref aint.
    uint32_t uiStringTableLength; ///< \brief Length of this data's string table.
    uint32_t uiAcharTableLength; ///< \brief Length of this data's alphabet character table.
    uint32_t uiPpptTableLength; ///< \brief Length of this data's PPPT.
    uint32_t uiParserInitLength; ///< \brief Length of the parser initialization data.
    const char* cpStringTable; ///< \brief Pointer to the string table.
    const uint8_t* ucpPpptTable; ///< \brief Pointer to the PPPT or NULL if none.
    const void* vpAcharTable; ///< \brief Pointer to the alphabet character table or NULL if none. (Possible for small grammars.)
    const void* vpParserInit; ///< \brief Pointer to the parser's initialization data.
} parser_init;


/** \struct init_hdr
 * \brief Header for the parser initialization data.
 *
 * This header section of the parser's initialization data defines some of the parser's basic data sizes, types and limits.
 * The remainder defines the offsets (from the beginning of the parser initialization data) to various
 * other data segments.
 *
 * CAVEAT: This structure must match exactly \ref init_hdr_out in the API file output.c.
 */
typedef struct  {
    luint uiSizeInInts; /**< \brief The number of integers in the initialization data, including this header. */
    luint uiAcharMin; /**< \brief The minimum value of all of the alphabet characters (\ref achar) present in the grammar. */
    luint uiAcharMax; /**< \brief The maximum value of all of the alphabet characters (\ref achar) present in the grammar. */
    luint uiSizeofAchar; /**< \brief The minimum size, in bytes, required to hold all alphabet characters in the grammar. */
    luint uiUintMax; /**< \brief The maximum value of all of the integers present in this initialization data. */
    luint uiSizeofUint; /**< \brief The minimum integer size, in bytes,
                        required to hold all of the integers in the initialization data. */
    luint uiRuleCount; /**< \brief The number of rules in the grammar. */
    luint uiUdtCount; /**< \brief The number of UDTs in the grammar. */
    luint uiOpcodeCount; /**< \brief The number of opcodes in the grammar. */
    luint uiMapCount; /**< \brief The number rule, UDT, and opcode PPPT maps. */
    luint uiMapSize; /**< \brief The number of bytes in one PPPT map. */
    luint uiVersionOffset; /**< \brief Offset from the beginning of the string table to the null-terminated version number string. */
    luint uiCopyrightOffset; /**< \brief Offset from the beginning of the string table to the null-terminated copyright string. */
    luint uiLicenseOffset; /**< \brief Offset from the beginning of the string table to the null-terminated license string. */
    luint uiChildListOffset; /**< \brief  Offset from the beginning of the initialization data to the
                             list of ALT and CAT child node opcode indexes. */
    luint uiChildListLength; /**< \brief  The number of integers in the child index list. */
    luint uiRulesOffset; /**< \brief  Offset from the beginning of the initialization data to the
                         to the list of rules. */
    luint uiRulesLength; /**< \brief  Number of integers in the rules list. */
    luint uiUdtsOffset; /**< \brief Offset from the beginning of the initialization data to the
                         to the list of UDTs. */
    luint uiUdtsLength; /**< \brief Number of integers in the UDT list. */
    luint uiOpcodesOffset; /**< \brief Offset from the beginning of the initialization data to the
                         to the list of opcodes. */
    luint uiOpcodesLength; /**< \brief Number of integers in the opcode list. */
} init_hdr;


// runtime opcodes
struct parser_tag;
/** \union opcode_tag
 * \brief A union of all possible node type opcode data structures.
 *
 * Each node operation requires its own unique set of data (the opcode) to carry out its operation.
 * This union serves to create a generalized opcode that can be deconstructed by each node type.
 */
union opcode_tag;
/** \typedef pfn_op
 * \brief Prototype for the node operation functions.
 * \param spCtx Pointer to the parser object's context.
 * \param spOp Pointer to the node operation's opcode (all the data required to define and execute the node operation).
 */
typedef void (*pfn_op)(struct parser_tag* spCtx, const union opcode_tag* spOp);

/** \struct rule
 * \brief Data structure for a single rule.
 */
typedef struct  {
    const char* cpRuleName; /**< \brief Pointer to the (null-terminated) ASCII rule name. */
    const uint8_t* ucpPpptMap; /**< \brief Pointer to the PPPT map for the rule. */
    const union opcode_tag* spOp; /**< \brief Pointer to the first opcode of the rule. */
    aint uiOpcodeCount; /**< \brief Number of opcodes in this rule. */
    parser_callback pfnCallback; /**< \brief Pointer to the call back function for this rule.
                    NULL if the user has not defined a call back function for this rule. See \ref vParserSetRuleCallback(). */
    aint uiEmpty; /**< \brief APG_TRUE if this rule can be empty, APG_FALSE otherwise. */
    aint uiRuleIndex; /**< \brief The rule index - zero-based order in which the rule appears in the SABNF grammar. */
} rule;

/** \struct udt
 * \brief Data structure for a single UDT.
 */
typedef struct  {
    const char* cpUdtName; /**< \brief Pointer to the (null-terminated) ASCII rule name. */
    parser_callback pfnCallback; /**< \brief  Pointer to the call back function for this UDT.
                                 The parser will throw an exception if this is NULL. See \ref vParserSetUdtCallback()*/
    aint uiEmpty; /**< \brief APG_TRUE if this UDT can be empty, APG_FALSE otherwise.
                 Parser will throw an exception if this if false and the call back function returns an empty string. */
    aint uiUdtIndex; /**< \brief The UDT index - the zero-based order in which the UDT appears in the SABNF grammar. */
} udt;

// opcodes
/** \struct op_alt
 * \brief Data structure for a single ALT opcode.
 */
typedef struct  {
    aint uiId; ///< \brief The operation identifier, ID_ALT.
    const uint8_t* ucpPpptMap; ///< \brief Pointer to the PPPT map for this opcode, if any.
    const aint* uipChildList; ///< \brief Pointer to the first child opcode index.
    aint uiChildCount; ///< \brief Number of children.
} op_alt;

/** \struct op_cat
 * \brief Data structure for a single CAT opcode.
 */
typedef struct  {
    aint uiId; ///< \brief The operation identifier, ID_ALT.
    const uint8_t* ucpPpptMap; ///< \brief Pointer to the PPPT map for this opcode, if any.
    const aint* uipChildList; ///< \brief Pointer to the first child opcode index.
    aint uiChildCount; ///< \brief Number of children.
} op_cat;

/** \struct op_rep
 * \brief Data structure for a single REP opcode.
 */
typedef struct  {
    aint uiId; ///< \brief The operation identifier, ID_ALT.
    const uint8_t* ucpPpptMap; ///< \brief Pointer to the PPPT map for this opcode, if any.
    aint uiMin; ///< \brief Minimum number of repetitions allowed.
    aint uiMax; ///< \brief Maximum number of repetitions allowed.
} op_rep;

/** \struct op_rnm
 * \brief Data structure for a single RNM opcode.
 */
typedef struct  {
    aint uiId; ///< \brief The operation identifier, ID_ALT.
    const uint8_t* ucpPpptMap; ///< \brief Pointer to the PPPT map for this opcode, if any.
    rule* spRule; ///< \brief Pointer to the rule for this operation.
}op_rnm;

/** \struct op_trg
 * \brief Data structure for a single TRG opcode.
 */
typedef struct  {
    aint uiId; ///< \brief The operation identifier, ID_ALT.
    const uint8_t* ucpPpptMap; ///< \brief Pointer to the PPPT map for this opcode, if any.
    achar acMin; ///< \brief Minimum alphabet character in the allowed range.
    achar acMax; ///< \brief Maximum alphabet character in the allowed range.
} op_trg;

/** \struct op_tls
 * \brief Data structure for a single TLS opcode.
 */
typedef struct  {
    aint uiId; ///< \brief The operation identifier, ID_ALT.
    const uint8_t* ucpPpptMap; ///< \brief Pointer to the PPPT map for this opcode, if any.
    const achar* acpStrTbl; ///< \brief Pointer to the alphabet character table for the first character of the allowed string.
    aint uiStrLen; ///< \brief Number of characters in the string.
} op_tls;

/** \struct op_tbs
 * \brief Data structure for a single TBS opcode.
 */
typedef struct  {
    aint uiId; ///< \brief The operation identifier, ID_ALT.
    const uint8_t* ucpPpptMap; ///< \brief Pointer to the PPPT map for this opcode, if any.
    const achar* acpStrTbl; ///< \brief Pointer to the alphabet character table for the first character of the allowed string.
    aint uiStrLen; ///< \brief Number of characters in the string.
} op_tbs;

/** \struct op_udt
 * \brief Data structure for a single UDT opcode.
 */
typedef struct  {
    aint uiId; ///< \brief The operation identifier, ID_ALT.
    const uint8_t* ucpPpptMap; ///< \brief Pointer to the PPPT map for this opcode, if any.
    udt* spUdt; ///< \brief Pointer to the UDT structure.
    aint uiEmpty; ///< \brief True if this UDT can return EMPTY, false otherwise.
} op_udt;

/** \struct op_and
 * \brief Data structure for a single AND opcode.
 */
typedef struct  {
    aint uiId; ///< \brief The operation identifier, ID_ALT.
    const uint8_t* ucpPpptMap; ///< \brief Pointer to the PPPT map for this opcode, if any.
} op_and;

/** \struct op_not
 * \brief Data structure for a single NOT opcode.
 */
typedef struct  {
    aint uiId; ///< \brief The operation identifier, ID_ALT.
    const uint8_t* ucpPpptMap; ///< \brief Pointer to the PPPT map for this opcode, if any.
} op_not;

/** \struct op_bkr
 * \brief Data structure for a single BKR opcode.
 */
typedef struct  {
    aint uiId; ///< \brief The operation identifier, ID_ALT.
    const uint8_t* ucpPpptMap; ///< \brief Pointer to the PPPT map for this opcode, if any.
    aint uiRuleIndex; ///< \brief Index of the rule to back reference.
    aint uiCase; ///< \brief
    aint uiMode; ///< \brief
} op_bkr;

/** \struct op_bka
 * \brief Data structure for a single BKA opcode.
 */
typedef struct  {
    aint uiId; ///< \brief The operation identifier, ID_ALT.
    const uint8_t* ucpPpptMap; ///< \brief Pointer to the PPPT map for this opcode, if any.
} op_bka;

/** \struct op_bkn
 * \brief Data structure for a single BKN opcode.
 */
typedef struct  {
    aint uiId; ///< \brief The operation identifier, ID_ALT.
    const uint8_t* ucpPpptMap; ///< \brief Pointer to the PPPT map for this opcode, if any.
} op_bkn;

/** \struct op_abg
 * \brief Data structure for a single ABG opcode.
 */
typedef struct  {
    aint uiId; ///< \brief The operation identifier, ID_ALT.
    const uint8_t* ucpPpptMap; ///< \brief Pointer to the PPPT map for this opcode, if any.
} op_abg;

/** \struct op_aen
 * \brief Data structure for a single AEN opcode.
 */
typedef struct  {
    aint uiId; ///< \brief The operation identifier, ID_ALT.
    const uint8_t* ucpPpptMap; ///< \brief Pointer to the PPPT map for this opcode, if any.
} op_aen;
/** \struct op_gen
 * \brief General opcode. Only holds the opcode ID and PPPT map pointer.
 *
 * NOTE 1.: *ALL* opcodes *MUST* have the opcode identifier (e.g. ID_ALT) as the first element
 * and the pointer to the PPPT map second.<br>
 * NOTE 2.: Since the opcode IDs are also used as indexes into an array of opcode functions,
 * they are sequential from 0 or 1.
 * ID_GEN must be larger than all other opcode IDs, since it is used for the array max.
 *
 */
typedef struct  {
    aint uiId; ///< \brief The opcode identifier e.g. ID_ALT
    const uint8_t* ucpPpptMap; ///< \brief Pointer to the PPPT map for this opcode, if any.
} op_gen;


typedef union opcode_tag {
    op_gen sGen; /**< \brief Each opcode has its ID as the first integer.
                    This general opcode serves only the purpose of getting the ID of an opcode of previously unknown type. */
    op_alt sAlt; ///< \brief The alternation ALT opcode.
    op_cat sCat; ///< \brief The concatenation CAT opcode.
    op_rep sRep; ///< \brief The repetition REP opcode.
    op_rnm sRnm; ///< \brief The rule name RNM opcode.
    op_trg sTrg; ///< \brief The terminal range TRG opcode.
    op_tbs sTbs; ///< \brief The terminal binary string TBS opcode.
    op_tls sTls; ///< \brief The terminal literal string TLS opcode.
    op_udt sUdt; ///< \brief The User-Defined Terminal UDT opcode.
    op_and sAnd; ///< \brief The positive look ahead AND opcode.
    op_not sNot; ///< \brief The negative look ahead NOT opcode.
    op_bkr sBkr; ///< \brief The back reference BKR opcode.
    op_bka sBka; ///< \brief The positive look behind BKA opcode.
    op_bkn sBkn; ///< \brief The negative look behind BKN opcode.
    op_abg sAbg; ///< \brief The begin-of-string anchor ABG opcode.
    op_aen sAen; ///< \brief The end-of-string anchor AEN opcode.
} opcode;

// parser context
/** \struct parser_tag
 * \brief The parser object's context. Holds the parser's state. Opaque to user.
 */
typedef struct parser_tag {
    // basic objects
    const void* vpValidate; /**< \brief  Set to a "magic number" by the constructor.
                 Must be valid for all other parser function calls. */
    exception* spException; /**< \brief  Pointer to the exception structure to use for reporting fatal errors.*/
    void* vpMem; /**< \brief  Pointer to a memory object context used for all memory allocations by the parser. */
    void* vpAst; /**< \brief Pointer to the AST object context, if any. See \ref vpAstCtor(). */
    void* vpTrace; /**< \brief Pointer to the trace object context, if any. See \ref vpTraceCtor(). */
    void* vpStats; /**< \brief Pointer to the stats object context, if any. See \ref vpStatsCtor(). */
    void* vpBkru; /**< \brief Pointer to the universal-mode back reference object context, if any. See \ref vpBkruCtor(). */
    void* vpBkrp; /**< \brief Pointer to the parent-mode back reference object context, if any. See \ref vpBkrpCtor(). */
    pfn_op* pfnOpFunc; /**< \brief  Pointer to the current node operation function. */

    // grammar data
    const char* cpStringTable; /**< \brief  Pointer to the ASCII string table with rule and UDT names. */
    const achar* acpAcharTable; /**< \brief  Pointer to the alphabet character table for TLS and TBS operators. */
    const aint* uipChildList; /**< \brief  Pointer to the table of child indexes for ALT and CAT operators*/
    rule* spRules; /**< \brief  Pointer to the list of rules. */
    udt* spUdts; /**< \brief  Pointer to the list of UDTs.*/
    opcode* spOpcodes; /**< \brief  Pointer to the list of opcodes. */
    aint uiRuleCount; /**< \brief  The number of rules in the SABNF grammar. */
    aint uiUdtCount; /**< \brief  The number of UDTs in the SABNF grammar. */
    aint uiOpcodeCount; /**< \brief  The number of opcodes (node operations) generated by the SABNF grammar. */

    // input data
    aint uiStartRule; /**< \brief  The current index of the start rule. */
    void* vpVecInputString; /**< \brief  Vector to keep a copy of the input string. */
    const achar* acpInputString; /**< \brief  Pointer to the input string. */
    aint uiInputStringLength; /**< \brief  Number of characters in the input string. */
    aint uiSubStringBeg; /**< \brief  The offset to the first character of the sub-string to parse. */
    aint uiSubStringEnd; /**< \brief  The offset to the first character beyond the end of the sub-string to parse. */
    aint uiSubStringLength; /**< \brief The number of characters in the substring to parse.*/

    // look around management
    aint uiLookBehindLength; /**< \brief  The maximum number of character to search for a match in look behind. */
    aint uiInLookaround; /**< \brief  True if in look ahead or look behind mode. */

    // PPPT
    const uint8_t* ucpMaps; /**< \brief  Pointer to the PPPT maps. */
    aint uiMapSize; /**< \brief  Number of bytes in a single PPPT map. */
    aint uiMapCount; /**< \brief  Number of maps in the PPPT. */
    achar acAcharMin; /**< \brief  The minimum alphabet character referenced by the SABNF grammar. */
    achar acAcharMax; /**< \brief The maximum alphabet character referenced by the SABNF grammar. */


    // parsing control
    aint uiOffset; /**< \brief  Offset to the current phrase to parse. */
    aint uiPhraseLength; /**< \brief  Phrase length of a matched phrase. */
    aint uiOpState; /**< \brief State of the current opcode being processed. */
    opcode sStartOp; /**< \brief Placeholder for the parser-generated RNM operator of the start rule.
                     The root node of the parse tree. */
    callback_data sCBData; /**< \brief The callback data,
                        initialized by the parser and passed to user-defined call back functions. */
    aint uiTreeDepth; /**< \brief The current parse tree depth. */

    // parsing state
    parser_state sState; /**< \brief The final state of the parser. */
} parser;

void* vpParserAllocCtor(exception* spException, void* vpParserInit, abool bAllocateTables);
aint uiGetAcharTable(parser_init* spHdr, achar* acpAcharTable);
abool bGetParserInitData(parser_init* spHdr, luint* luipParserInit);
void vGetChildListTable(init_hdr* spHdr, aint* uipList);
void vTranslateRules(parser* spCtx, rule* spRules, opcode* spOpcodes, luint* luipData);
void vTranslateUdts(parser* spCtx, udt* spUdts, luint* luipData);
void vTranslateOpcodes(parser* spCtx, rule* spRules, udt* spUdts, opcode* spOpcodes, luint* luipData);
uint8_t ucGetMapVal(const uint8_t* ucpMap, luint luiOffset, luint luiChar);

#ifndef APG_NO_PPPT
void vDisplayMap();
abool bPpptEval(parser* spCtx, const opcode* spOp, aint uiOffset);
aint uiPpptState(parser* spCtx, const opcode* spOp, aint uiOffset);
#endif /* APG_NO_PPPT */

#endif /* LIB_PARSERP_H_ */
